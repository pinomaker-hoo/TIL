# Typescript

## 개요

이 글은 타입스크립트 프로그래밍 책을 읽고 정리한 내용 입니다.

[타입스크립트 프로그래밍 - Boris Czerny](https://product.kyobobook.co.kr/detail/S000001033092)

## 목차

- [1. Typescript를 사용하는 이유](#1-typescript를-사용하는-이유)
- [2. typescript의-동작-원리](#2-typescript의-동작-원리)
- [3. 타입 시스템](#3-타입-시스템)
  - [(1) 타입이 어떻게 결정되는가](#3-1-타입이-어떻게-결정되는가)
  - [(2) 자동으로 타입이 변환되는가](#3-2-자동으로-타입이-변환되는가)

## 1. Typescript를 사용하는 이유

Typescript는 개발자에게 문서화를 제공하고, 리팩터링을 쉽게 만들며, 단위 테스트의 숫자를 절반으로 줄일 수 있어 더 안전한 프로그램을 구현할 수 있게 보장한다.

여기서 "안전한"이라는 단어는 타입 안전성을 의미한다.

```
타입 안전성 (type safety)
타입을 이용해 프로그래밍이 유효하지 않은 작업을 수행하지 않도록 방지한다.
```

아래의 예시들은 유효하지 않은 작업에 대한 예시다.

- 숫자와 리스트를 곱한다.
- 객체에 존재하지 않는 멤버 함수를 호출한다.

일부 언어들은 이런 오류가 발생하는 코드들이더라도 최대한 실행할려고 노력한다. 그 중 하나가 Javascript로 예시를 한 번 보자.

```javascript
3 + []; // "3"으로 평가

let obj = {};
obj.foo; // undefiend로 평가

function a(b) {
  return b / 2;
}
a("Z"); // NaN으로 평가
```

분명히 잘못된 동작이지만 Javascript는 예외를 던지지 않고 결과를 도출한다. 이러한 문제를 바로 잡기 위하여 Typescript가 등장하였고 Typescript는 에러를 알려준다는 사실도 훌륭하지만 코드를 작성한 순간 바로 에러를 알려주는 것이 개발자에게 매우 좋은 경험을 제공한다.

## 2. Typescript의 동작 원리

이번 목차에서는 Typescript Compiler(TSC)의 동작 원리에 대해서 알아보고자 한다.

프로그램은 프로그래머가 작성한 다수의 텍스트 파일로 구성되며 이 파일들을 컴파일러라는 특별한 프로그램이 파싱하여 추상 문법 트리(AST)라는 자료 구조로 변환한다.

이 AST는 공백, 주석, 탭등을 완전히 무시하고 다시 컴파일러는 AST를 바이트코드라는 하위 수준의 표현으로 변환하고, 이를 runtime이라는 다른 프로그램에 바이트 코드를 입력하여 평가하고 결과를 얻을 수 있다.

```
1. 프로그램이 컴파일러에 의하여 AST로 파싱된다.
2. AST는 다시 컴파일러에 의하여 바이트코드로 컴파일된다.
3. Runtime이 바이트코드르 평가한다.
```

여기서 Typescript가 다른 언어와 다른 점은 컴파일러가 코드를 바이트코드 대신에 Javascript 코드로 변환하게 된다. 이 때 TSC는 AST를 만들어 결과 코드를 내놓기 전에 타입 확인을 거치게된다.

```
타입 검사기(Typechecker)
코드의 타입 안전성을 검증하는 특별한 프로그램
```

[
![images_ggob_2_post_be680c2c-123b-473a-9cf0-4906ca18fb58_TSC](https://github.com/pinomaker-hoo/TIL/assets/56928532/c43ff164-83d6-40fb-9a17-98182de179ce)
](url)

## 3. 타입 시스템

```
타입 시스템(Type system)
타입 검사기가 프로그램에 타입을 할당하는 데 사용하는 규칙 집합
```

타입 시스템은 보통 어떤 타입을 사용하는 지 컴파일러에 명시적으로 알려주는 타입 시스템과 자동으로 타입을 추론하는 타입 시스템인 2가지로 구분된다.

타입 스크립트는 두 가지 시스템 모두의 영향을 받았기에 명시적으로 타입을 지정하거나 타입을 추론하는 방식 중에서 선택 할 수 있다.

```typescript
const a: number = 3;
const b: string = "Hello world";
const c: boolean[] = [true, false];

const d = 3; // number로 추론
const e = "Hello world"; // string으로 추론
```

하지만 타입스크립트가 타입을 추론하도록 두는 것이 코드를 줄일 수 있는 방법이라 보통은 타입을 추론하게 두는 편이다.

| 타입 시스템 기능 | javascript | typescript   |
| ---------------- | ---------- | ------------ |
| 타입 결정 방식   | 동적       | 정적         |
| 타입 자동 변환   | O          | X            |
| 타입 확인 시기   | runtime    | compile time |
| 에러 검추 시기   | runtime    | compile time |

### 3-1. 타입이 어떻게 결정되는가?

Javascript는 동적 타입 바인딩(Dynamic type binding)이라 프로그램을 실행해야만 특정 데이터의 타입을 확인 할 수 있음을 의미한다.

Typescript는 점진적으로 타입을 확인해야하는 언어다. 즉 타입 스크립트는 컴파일 타임에 프로그램의 모든 타입을 알고 있을 때 최상의 결과를 보여줄 수 있지만 컴파일 할 때 모든 타입을 반드시 알아야하는 것은 아니다.

점진적 타입 확인은 타입을 지정하지 않은 기존 Javascript를 Typescript로 마이그레이션할 때 유용하다. 하지만 그런 상황이 아니라면 모든 코드의 타입을 컴파일 타임에 지정하는 것을 목표로 해야한다.

### 3-2. 자동으로 타입이 변환되는가?

Javascript는 약한 타입의 언어이기에 아까 했던 것과 같이 유효하지 않은 연산을 수행해도 최대한 실행할려고 노력하기에 아래와 같이 평가하게 된다.

```javascript
3 + [1]; // "31"으로 평가
```

위의 예시처럼 Javascript는 영리하게 타입을 변환하려 노력하지만 Typescript는 유효하지 않은 작업을 발견하면 예외를 던지게된다.

```tavascript
3 + [1] // '+' 연산자를 '3'과 [1]에 사용할 수 없다.
```

올바르지 않아 보이는 연산을 수행하면 Typescript는 예외를 던지지만 Javascript는 예외를 던지지 않고 자동 변환하여 문제를 발생시키고 이를 추적하기 어렵게 만든다. 이런 부분 때문에 Typescript를 이용하여 타입을 체크하는 것이 좋다.

## 시스템의 Type

타입이란 단순하게 정수형, 문자열형만 있는 것이 아닌 그것을 포함한 그것으로 할 수 있는 모든 연산을 포함한다.

```
타입 (Type)
값과 이 값으로 할 수 있는 일의 집합
```

- Boolean Type은 모든 불과 불에 수행할 수 있는 모든 연산(||, &&, !)의 집합이다.

- number type은 모든 숫자와 숫자에 적용할 수 있는 모든 연산(+, -)뿐만 아니라 숫자에 호출할 수 있는 모든 메서드(.toFixed, .toString)도 포함된다.

어떤 값이 T 타입이라면 그 값을 아지고 어떤 일을 할 수 있는 지 어떤 일을 할 수 없는 지 알 수 있다. 여기서 중요한 것은 타입 검사기를 이용하여 유효하지 않은 동작이 실행되는 일을 방지하는 것이다.

![img](https://github.com/pinomaker-hoo/TIL/assets/56928532/4e5c83fe-98d9-41a7-9b97-cd533cda8f8b)

### (1) any

any는 뭐든 지 할 수 있지만 꼭 필요한 상황이 아니라면 사용하지 않는 것을 추천한다. 타입의 정의는 값과 그 값으로 할 수 있는 모든 작업의 집합인데, any는 모든 값의 집합이기에, 모든 것을 할 수 있어 Javascript와 같이 사용하는 것이다.

### (2) unknown

만약 내가 어떤 타입인지 미리 알 수 없는 값이라면 any 대신에 unknown을 사용하자. any처럼 모든 값을 대표하지만 타입을 검사하여 정제하기 전까진 타입스크립트가 unknown 타입의 값을 사용할 수 없도록 강제한다.

```typescript
const a: unknown = 30;
const b = a + 10; // Error, 객체의 타입이 unknow이다.

if (typeof a === "number") {
  const c = a + 10; // 40
}
```

위의 예제와 같이 사용하여 어떤 값이 들어올 지 모르는 상황을 대비할 수 있다.

### (3) boolean
