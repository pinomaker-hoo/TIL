# Index

인덱스는 데이터의 저장의 성능을 희생하고, 읽기 속도를 높이는 테이블의 동작 속도를 높여주는 자료 구조다.

인덱스는 데이터베이스를 작동하는 데 필수 요소는 아니지만 데이터베이스 크기가 커질 수록 반드시 필요해진다. 특정 데이터를 SELECT 할 때 n 분이 걸리던 것이 0.n초로 끝낼 수 있을 정도이다. 인덱스를 잘 사용한다면 빠른 응답 속도를 얻을 수 있고, 쿼리의 부하가 줄어들기에, 시스템 전체 성능이 향상되지만 인덱스도 하나의 덩어리이기에 전체 크기의 10%나 되는 추가적인 공간을 할당해야하며 잘못 사용하면 성능이 오히려 떨어진다.

## 인덱스 알고리즘

### 1. B-Tree 인덱스 알고리즘

MySQL에서는 B-Tree 인덱스 알고리즘을 사용하는 데 컬럼의 값을 변형하지 않고 기존 값을 이용해 인덱싱하는 알고리즘이다. B-Tree는 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태이다.

해당 인덱스의 가장 큰 장점은 어떤 데이터를 조회하든 조회 과정의 길이 및 비용이 균등하다.

<br />

## 2. Hash 인덱스 알고리즘

Hash 인덱스 알고리즘은 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원하지만 값을 변형하기에 동등 비교 검색에는 최적화 되어있지만 범위 검색이나 정렬을 목적으로는 사용할 수 없고 주로 인메모리 DB에서 사용한다.

해시 인덱스의 장점으로는 실제 키값과 상관없이 인덱스 크기가 작고 검색이 빠르며, 원래의 키값을 저장하는 것이 아닌 해시 함수의 결과만 저장하기에 원본 키 값이 아무리 길어도 인덱스에 저장되는 값은 4-8 바이트 수준으로 줄어즌다. 그래서 타 인덱스 대비하여 속도가 매우 빠르다.

<br />

## 3. Fractal-Tree 알고리즘

Fractal-Tree 알고리즘은 B-Tree의 단점을 보완하기 위해 고안된 알고리즘으로, 값을 변형하지 않고 인덱싱하여 범용적인 목적으로 사용할 수 있으면서 데이터가 저장되거나 삭제 될 때 처리 비용을 상당히 줄일 수 있게 설계되어있다.

<br />

## 인덱스 종류

인덱스는 Primary Index(클러스터)와 Secondary Index(보조)로 나누어진다.
