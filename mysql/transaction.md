# Transaction

## 1. Transaction

트랜잭션이라 데이터베이스에서 처리하는 단위를 말하며, 원자성, 일관성, 격리성, 영속성 4가지 특징을 가지고 있다.

- 원자성(Atomicity)

  트랜잭션은 분해가 불가능한 가장 작은 단위이기에 1개의 트랜잭션은 전부 처리되거나 하나도 처리되면 안 된다.

- 일관성(Consistency)

  일관된 상태의 데이터베이스에서 하나의 트랜잭션이 성공하면 데이터베이스는 일관된 상태여야한다.

- 격리성(Isolation)

  실행 중인 트랜잭션의 중간 결과를 다른 트랜잭션에서 접근이 불가능해야한다.

- 영속성(Durability)

  트랜잭션이 성공적으로 완료되면 결과가 데이터베이스에 영속적으로 저장되어야한다.

## 2. DB Lock

Lock은 동시에 여러 프로세스나 스레드가 공유하는 리소스에 대한 접근을 조절한다. 여러 프로세스나 스레드가 동시에 같은 리소스를 수정하게되면 동시성 문제나 일관성을 유지할 수 없기에 적절하게 사용해야한다.

이를 DB 관점에서 바라보면 A, B 트랜잭션에서 같은 Row에 대해서 접근하여 조회하거나 수정할려고 할 때는 문제가 발생할 수 있다. 이를 위하여 동시에 같은 Row에 접근을 못 하게 적절하게 Lock을 걸어주는 것이 중요하다.

### DB Lock 설정 범위

DB Lock은 적용할 수 있는 설정 범위가 다양하다.

- 데이터베이스 : 전체 데이터 베이스를 기준으로 Lock을 설정하며 1개의 트랜잭션만이 접근 가능하지만 잘 사용하지 않는다.

- 파일 : 데이터베이스 파일을 기준으로 Lock을 설정하는 데 여기서 파일이란 테이블, Row 등 실제 데이터가 쓰여지는 물리적인 저장소이다.

- 테이블 : 테이블의 모든 행을 업데이터 하는 등의 전체 테이블에 영향을 주는 변경을 수행할 때 유용하며, DDL 구문과 함께 사용되어 DDL Lock이라고도 불린다.

- 페이지, 블럭 : 파일의 일부인 페이지나 블록을 기준으로도 가능하지만 잘 사용하지 않는다.

- 컬럼 : 지원하는 DBMS도 적고, 설정 및 해제의 리소스가 많이 들어 잘 사용하지 않는다.

- 행 : 1개의 행을 기준으로 Lock을 설정하는 데 가장 기본적으로 사용하게 된다.

### DB Lock의 종류

1. 공유락(Shared Lock)

   데이터를 조회할 경우 사용 되어 Read Lock이라고도 하며, S로 자주 표기한다. 여러 사용자가 동시에 데이터를 읽어도 문제가 없어도 데이터 일관성에 영향을 주지 않아 동시에 접근이 가능하다. 이는 동시에 접근하여 조회는 가능하지만 수정은 불가능하다는 것이며, 공유 락이 설정된 상태에서는 베타 락을 사용할 수 없다.

2. 베타 락(Exclusive Lock)

   베타 락은 데이터를 변경할 때 사용하는 Lock으로 Write Lock이라고 하며, X로 표기한다. 다른 세션이 해당 자원에 조회 및 수정하는 것을 막고 트랜잭션이 완료할 때까지 유지된다. 즉 다른 트랜잭션은 Lock 대상에 대해 접근이 불가하다.

3. 업데이트 락(Update Lock)

   업데이트 락은 테이블을 수정하기 위해 베타 락을 걸기 전에 데드 락을 방지하고 위해서 사용한다. 일반적으론 UPDATE 쿼리의 WHERE 절에서 실행돈다.

4. 내재 락(Intent Lock)

   사용자가 요청한 범위에 대하여 락을 걸 수 있는 지 여부를 파악하기 위해 사용되며 공유락과 베타락 앞에 I를 붙여서 표기한다.

## 트랜잭션의 격리성

트랜잭션의 4가지 특징 중 격리성은 실행 중인 트랜잭션의 중간 결과를 다른 트랜잭션이 접근할 수 없다는 것이지만 실제로는 접근 레벨이 있기에 DB에 따라 설정이 가능하다.

즉 설정에 따라 격리성을 강하게 처리하거나 약하게 처리할 수 있다.

트랜잭션의 격리성으로 인해 나타나는 문제점으로는 Dirth Read, Non-Repeatable, Phantom Read가 있다.

1. Dirth Read

   Dirty Read는 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터를 읽는 것을 의미한다. A 트랜잭션에서 Insert를 하고 Commit이 되지 않은 상태에서 B 트랜잭션에서 Select를 했으나 A 트랜잭션이 Rollback이 된다면 B 트랜잭션에서의 데이터는 그대로이기에 잘못된 로직을 처리할 수도 있다.

2. Non-Repeatable Read

   한 트랜잭션 내에서 같은 Key를 가진 Row를 2번 읽었는 데 그 사이에 값이 변경되거나 삭제되어 결과가 다르게 나오는 현상이다.

3. Phantom Read

   한 트랜잭션에서 같은 쿼리를 2번 수행했는 데 1번째 쿼리에선 없던 유령 레코드가 두 번쨰 쿼리에서 나타나는 현상이다.

## 낙관적락, 비관적락

데이터의 동시성 문제를 해결하기 위해 사용할 수 있는 방법으로는 낙관적락과 비관적락을 사용할 수 있다.

### 낙관적락

낙관적 락은 데이터를 읽을 때는 락을 걸지 않고 데이터를 업데이트할 때만 이전 데이터와 현재 데이터를 비교하여 충돌 여부를 판단한다.

해당 방식은 데이터베이스 성능 저하를 최소화하고 동시성을 높이는 데 이점이 있다.

낙관적 락의 장점은 데이터를 읽는 동안 다른 트랜잭션이 해당 데이터를 변경할 수 있기에 성능이 좋고 Deadlock 발생 가능성이 낮다는 것이지만 충돌이 발생했을 때 데이터를 다시 읽고 업데이트 해야하는 추가 작업이 필요하다. 낙관적 락은 데이터가 업데이트 될 때 마다 버전 번호를 증가시키고 이를 검사하여 충돌은 감지하는 방식으로 낙관적 락을 구현합니다.

### 비관적락

비관적 락은 데이터를 읽을 때마다 해당 데아터에 대한 락을 걸어 다른 트랜잭션이 해당 데이터를 변경 할 수 없게하는 데 비관적 락은 데이터의 일관성을 유지하는 데 목적이 있다. 데이터를 읽는 동안 다른 트랜잭션이 해당 데이터를 변경할 수 없기에 데이터의 일관성을 제공하지만 성능 저하와 데드락 발생 가능성이 높다.

비관적 락은 데이터베이스의 락 기능을 사용하여 구현할 수 있다.
