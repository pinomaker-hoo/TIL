# 개발에서 날짜/시간 다룰 때 꼭 신경 써야 할 것들

날짜와 시간은 많은 버그와 사용자 불만의 근원이 됩니다. 특히 글로벌 서비스나 장기적으로 유지보수되는 시스템에서는, 초기에 날짜/시간을 대충 설계하면 나중에 고치기 어렵습니다.

개발할 때 반드시 의식해야 할 날짜/시간 포인트들을 정리했습니다.

---

## 1. 시간대(Time Zone)

- **UTC 기준 저장, 로컬 기준 표시**
  - DB에는 가능하면 UTC로 저장 (`2025-11-21T00:59:00Z`)
  - 화면에는 사용자의 타임존으로 변환해서 표시
- **서버 타임존 vs 클라이언트 타임존**
  - 서버는 여러 리전에 있을 수 있음
  - 브라우저/모바일은 사용자의 로컬 타임존 사용
- **타임존 변환은 라이브러리에 맡기기**
  - 직접 오프셋 계산하지 말고 Luxon 같은 라이브러리를 사용

### 1-1. 타임존/UTC 기본 개념과 표기 요약

- **UTC (Coordinated Universal Time)**

  - 국제 표준 시간, 타임존 기준축
  - 한국 시간(KST)은 보통 `UTC+09:00`
  - 개발에서는 "기준 시각"으로 가장 많이 사용

- **오프셋(offset)**

  - `UTC+09:00`, `UTC-05:00`처럼 UTC에서 얼마나 차이 나는지 표시
  - 같은 국가여도 DST 여부에 따라 오프셋이 달라질 수 있음

- **타임존 ID (IANA Time Zone)**

  - 예: `Asia/Seoul`, `America/New_York`, `Europe/London`
  - 단순 오프셋(`+09:00`)보다 **IANA ID**를 쓰는 것이 안전
    - 이유: 오프셋은 DST/법 개정 등으로 자주 바뀌지만, IANA ID는 규칙을 포함하고 있음

- **대표적인 타임존 예시**

  - `Asia/Seoul` → 일반적으로 `UTC+09:00` (DST 없음)
  - `Asia/Tokyo` → `UTC+09:00` (DST 없음)
  - `America/Los_Angeles` → `UTC-08:00` 또는 `UTC-07:00` (DST 있음)
  - `America/New_York` → `UTC-05:00` 또는 `UTC-04:00` (DST 있음)
  - `Europe/London` → `UTC+00:00` 또는 `UTC+01:00` (DST 있음)

- **일반적인 표기 패턴**

  - **ISO 8601 + UTC**: `2025-11-21T01:00:00Z`
    - 끝의 `Z`는 `UTC+00:00`을 의미
  - **ISO 8601 + 오프셋 포함**: `2025-11-21T10:00:00+09:00`
    - KST(한국 시간) 시각을 명확히 표현할 때
  - **날짜만 필요한 경우**: `2025-11-21` (로컬/타임존 문맥을 코드/문서에서 함께 명시)

- **실무 팁**
  - 내부/저장/API에는 **가능하면 UTC 또는 UTC 오프셋이 포함된 ISO 8601 문자열 사용**
  - 사용자에게 보여줄 때만 IANA 타임존(`Asia/Seoul` 등)을 사용해 로컬 시각으로 변환
  - "어느 타임존 기준인지"를 문서/스키마/변수명에 분명히 적어 두기 (예: `created_at_utc`)

---

## 2. DST(일광 절약 시간제) / 오프셋 변화

- **존재하지 않는 시간 / 두 번 존재하는 시간**
  - DST 시작/종료 시 특정 시간이 "없거나" "두 번" 생김  
    예: `2025-03-30 02:30` 같은 시간
- **단순 덧셈은 위험**
  - `+9h`, `+1d` 같은 계산은 DST가 걸리는 구간에서는 실제 시간이 1시간 차이날 수 있음
- **`local time` 기준 연산보다 `UTC` 또는 `zoned time` 연산 선호**

---

## 3. 날짜 계산(기간, 차이)

- **날짜 더하기/빼기**
  - `+1 day`와 `+24 hours`는 항상 같지 않음 (DST 영향)
- **월 단위 계산**
  - `2025-01-31 + 1 month = ?`  
    → 2/28? 3/3? 사용하는 라이브러리가 어떻게 정의하는지 확인 필요
- **기간 비교 시 경계 정의**
  - 구간을 [start, end], [start, end) 등으로 명확히 정의
  - 쿼리와 비즈니스 로직에서 포함/제외 경계를 일관되게 사용할 것

---

## 4. 포맷(Formatting) & 파싱(Parsing)

- **표준 포맷 우선**
  - 내부/저장/API용에는 ISO 8601 (`2025-11-21T00:59:00Z`) 사용
- **모호한 문자열 피하기**
  - `01/02/2025` → 1월 2일인가, 2월 1일인가? 해석이 달라질 수 있는 포맷은 피하기
- **저장 포맷과 UI 포맷 분리**
  - 저장/전송은 항상 같은 포맷(예: ISO 8601)
  - 화면은 로케일(`ko-KR`, `en-US` 등)에 맞는 포맷으로 변환해서 표시

---

## 5. 로케일/캘린더 이슈

- **문화권마다 다른 규칙**
  - 요일 시작(월요일/일요일), 주 번호 계산 방식 다름
  - 12/24시간제 표기 차이
- **캘린더 시스템**
  - 대부분 Gregorian을 쓰지만, 일부 도메인은 다른 달력(음력 등) 고려 필요

---

## 6. 정밀도(Precision) & 단위

- **초/밀리초/나노초**
  - JS `Date`는 밀리초 정밀도
  - 백엔드/DB는 나노초까지 지원하는 경우도 있음
- **UNIX time 단위 혼동 주의**
  - 초 단위(10자리) / 밀리초 단위(13자리)를 혼동하면 수천 초/수천 배 차이가 생김

---

## 7. 저장/전송 전략

- **DB 저장 타입 이해**
  - `timestamp with time zone` vs `without time zone` 차이 이해
  - 원칙: UTC 기준으로 저장 + 필요 시 별도 타임존 정보 컬럼 보관
- **API 설계 시 명시**
  - 요청/응답 스펙에 타임존/포맷을 명시
  - 가능하면 모두 ISO 8601(UTC)로 통일하고, 클라이언트에서만 로컬로 변환

---

## 8. 반복/주기 이벤트

- **반복 규칙은 보통 "로컬 시간" 기준**
  - ex) "매일 오전 9시 알림" → 사용자의 타임존이 바뀌거나 DST가 바뀔 때 어떻게 동작할지 정의 필요
- **규칙 저장 vs 인스턴스 저장**
  - RRULE(반복 규칙)만 저장하고 매번 계산할지
  - 미리 여러 인스턴스를 생성해 둘지 도메인에 맞게 설계

---

## 9. 비교/정렬/동등성

- **비교/정렬은 되도록 UTC 기준**
  - `A < B` 비교 시 같은 타임존(보통 UTC)으로 맞춘 뒤 비교
- **"같은 날짜"의 의미 정의**
  - 같은 캘린더 날짜인지(local date 기준)
  - 완전 같은 시각인지(타임스탬프 기준)
  - 어떤 기준을 쓸지 도메인마다 다를 수 있으니 명시적으로 정할 것

---

## 10. 테스트 & 재현성

- **테스트 환경에서 타임존/시각 고정**
  - 테스트 실행 시 타임존과 기준 시간을 고정해 예측 가능한 결과를 확보
- **경계 케이스 테스트 추가**
  - 월말, 연말, 윤년(2/29), DST 시작/종료 구간 등은 별도 테스트 케이스로 관리

---

## 마무리

날짜/시간은 "돌려쓰기 좋은 유틸 몇 개"로 끝나는 주제가 아닙니다.  
처음 설계할 때부터:

- **저장 기준(UTC/타임존)**
- **표현 기준(UI 로케일, 포맷)**
- **비즈니스 룰(반복, 비교 기준, 기간 정의)**

을 명확히 정해두면, 나중에 전체 시스템을 갈아엎는 일을 상당 부분 막을 수 있습니다.
