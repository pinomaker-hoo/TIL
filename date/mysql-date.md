# MySQL에서 날짜/시간 다룰 때 신경 써야 할 것들

MySQL은 타입도 많고, 타임존 처리도 설정에 따라 달라지기 때문에 처음 설계를 잘못하면 나중에 되돌리기 어렵습니다.
여기서는 **애플리케이션에서 MySQL을 사용할 때** 날짜/시간에 대해 꼭 의식해야 하는 부분들을 정리합니다.

---

## 1. 주요 날짜/시간 타입 이해하기

MySQL(특히 5.x / 8.x 기준)에서 자주 쓰는 날짜/시간 타입:

- **`DATE`**

  - 연-월-일만 저장 (`YYYY-MM-DD`)
  - 시간 정보는 필요 없고, 캘린더 날짜만 중요할 때 사용 (예: 생년월일)

- **`TIME`**

  - 시:분:초만 저장 (`HH:MM:SS[.fraction]`)
  - 특정 날짜와 관계없는 시간 정보가 필요할 때 (예: 영업 시작 시각)

- **`DATETIME`**

  - `YYYY-MM-DD HH:MM:SS[.fraction]`
  - **타임존 정보가 없음** → 저장된 값은 “있는 그대로”의 벽시계 시각

- **`TIMESTAMP`**
  - 내부적으로 UTC로 보관, 클라이언트/세션 타임존에 맞춰 변환
  - 범위가 더 좁음 (`1970-01-01` ~ `2038-01-19` for 32-bit)

실무에서는 보통 아래 두 가지 전략 중 하나를 명확히 선택해야 합니다.

- **전략 A: `TIMESTAMP` + UTC 기반 설계**
- **전략 B: `DATETIME` + 애플리케이션에서 타임존 직접 관리**

---

## 2. 서버/세션 타임존 설정

MySQL은 타임존이 여러 단계에서 영향을 받습니다.

- **글로벌 설정**
  - `system_time_zone`
  - `time_zone` (글로벌)
- **세션 설정**
  - `SET time_zone = '+09:00';` 처럼 세션마다 변경 가능

`TIMESTAMP`는 **저장할 때 세션 타임존 기준 → 내부 UTC 변환 → 조회 시 다시 세션 타임존으로 변환**된다는 점을 반드시 이해해야 합니다.

- 애플리케이션에서:
  - 가능한 한 **DB 접속 직후 세션 타임존을 명시적으로 설정**하기
  - 예: 항상 `SET time_zone = '+00:00';` 또는 `SET time_zone = 'Asia/Seoul';`

---

## 3. `DATETIME` vs `TIMESTAMP` 선택 기준

- **`TIMESTAMP`를 선호하는 경우**

  - 애초에 **UTC 기준 시각**을 다루고, 클라이언트에서만 로컬로 변환
  - “로그 시각”, “이벤트 발생 시각” 처럼 절대 시점을 기록하는 값
  - 시간대가 변경되더라도 값이 변하면 안 되는 경우

- **`DATETIME`을 선호하는 경우**
  - **타임존과 상관없이 벽시계 시각 자체가 중요**할 때
    - 예: "영업 시작은 항상 오전 9시" (해당 지역의 로컬 타임 기준)
  - 애플리케이션 레벨에서 타임존을 명확하게 관리하는 경우
  - MySQL `TIMESTAMP` 범위를 넘어가는 연도까지 다뤄야 하는 경우

한 테이블/도메인 내에서 이 둘을 섞어 쓸 때는, **각 컬럼의 의미(절대 시점 vs 로컬 캘린더 시각)**를 주석이나 문서로 확실히 남겨두는 것이 좋습니다.

---

## 4. 애플리케이션과 MySQL 간 변환

### 4.1. UTC를 기준으로 하는 전략

- 애플리케이션 내부에서:
  - **모든 시간은 UTC 기준으로 처리** (서버 로컬 타임존에 의존하지 않기)
  - DB에는 `TIMESTAMP` 또는 `DATETIME(UTC)`로 저장
- 클라이언트(UI)에서:
  - 사용자의 타임존으로 변환해서 표시 (Luxon 등 라이브러리 사용)

이때 주의할 점:

- MySQL 세션 타임존이 UTC가 아니라면, `TIMESTAMP`는 자동 변환이 들어가기 때문에
  - **세션 타임존 = UTC로 강제**하거나
  - 애초에 `DATETIME` + 애플리케이션 UTC 처리 전략을 택하는 것이 더 단순할 수 있음

### 4.2. 로컬 타임존을 기준으로 하는 전략

- 특정 국가/지역 서비스만 고려하는 경우(예: 한국만 대상)
- `DATETIME`에 "한국 시간 기준" 시각을 그대로 저장
- 애플리케이션/DB 모두 `Asia/Seoul` 기준으로 동작하도록 통일

이 경우에도, **서버 시스템 시간**과 **MySQL `time_zone` 설정**이 다를 수 있으므로 항상 명시적으로 세션 타임존을 맞추는 습관이 좋습니다.

---

## 5. 인덱스와 범위 쿼리

날짜/시간 컬럼은 보통 **정렬/범위 검색**에 많이 쓰입니다.

- 자주 쓰는 패턴
  - `WHERE created_at BETWEEN '2025-01-01' AND '2025-01-31'`
  - `WHERE created_at >= '2025-01-01' AND created_at < '2025-02-01'`
- 인덱스 활용을 위해서는
  - 날짜 컬럼 자체에 인덱스를 걸고
  - 컬럼에 함수를 씌우지 않는 것이 좋음
    - 예: `WHERE DATE(created_at) = '2025-01-01'`는 인덱스를 잘 못 탈 수 있음

**포인트**: 날짜/시간 경계를 사용할 때, `[start, end)` 형태로 쓰는 것이 안전한 경우가 많습니다.

```sql
-- 1월 전체
WHERE created_at >= '2025-01-01 00:00:00'
  AND created_at <  '2025-02-01 00:00:00';
```

---

## 6. 기본값과 자동 업데이트

MySQL에서는 다음과 같은 패턴을 자주 씁니다.

```sql
created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
```

주의할 점:

- 이 패턴은 MySQL 버전에 따라 **한 테이블에서 `TIMESTAMP` 컬럼에 자동 기본값/업데이트를 둘 이상 쓰기 어려웠던 시절**이 있음 (5.x 구버전)
- `DATETIME`에도 8.0 이상에서는 `DEFAULT CURRENT_TIMESTAMP`가 가능

실무에서는 아래처럼 많이 정리합니다.

- **전략**
  - 가능하면 `created_at`, `updated_at` 모두 `DATETIME`(또는 `TIMESTAMP`) + `DEFAULT CURRENT_TIMESTAMP` 사용
  - "DB가 시간 기록을 담당"할지, "애플리케이션이 모두 기록"할지 팀 규칙을 정해서 통일

---

## 7. 문자열 <-> 날짜 변환 (`STR_TO_DATE`, `DATE_FORMAT`)

- **파싱**: `STR_TO_DATE(str, format)`
  - 예: `STR_TO_DATE('2025-11-21 10:30:00', '%Y-%m-%d %H:%i:%s')`
- **포맷팅**: `DATE_FORMAT(date, format)`
  - 예: `DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s')`

가능하면 **애플리케이션에서 날짜 파싱/포맷팅을 처리**하고, DB는 비교/저장/검색에 집중시키는 것이 좋습니다.  
특히 로케일(언어)에 따라 포맷이 달라지는 경우는 DB에서 처리하기 까다롭습니다.

---

## 8. 타임존이 섞인 데이터 마이그레이션 이슈

기존 시스템에서:

- 어떤 컬럼은 로컬 시각(예: KST) 기준 `DATETIME`으로 저장
- 어떤 컬럼은 UTC 기준 `DATETIME` 또는 `TIMESTAMP`로 저장

같은 테이블/같은 컬럼 내에 서로 다른 기준의 값이 섞여 있는 경우가 자주 발생합니다.

마이그레이션/정리 시에는:

- **각 컬럼/레코드가 어떤 기준으로 저장되었는지 먼저 파악**
- 필요하다면
  - 새로운 컬럼을 만들어 정규화된 기준(UTC 등)으로 옮기고
  - 애플리케이션 코드도 점진적으로 새 컬럼을 참조하도록 변경

---

## 9. ORM 사용 시 주의사항

TypeORM, Sequelize, JPA 등 ORM을 쓸 때는:

- 엔티티/모델의 타입(`Date`, `string`, `number`)과 DB 타입(`DATETIME`, `TIMESTAMP`) 매핑을 확인
- ORM이 내부적으로 **UTC로 저장하는지, 세션 타임존에 따라 변환하는지** 문서를 확인
- 테스트 코드에서
  - "DB에 이렇게 넣었을 때 애플리케이션에서 읽으면 어떤 값으로 나오는지"를 반드시 검증

ORM 기본 설정을 그대로 믿고 가다 보면, 타임존 관련 버그가 뒤늦게 터지기 쉽습니다.

---

## 10. MySQL에서의 베스트 프랙티스 정리

프로젝트 초기에 아래 정도는 팀에서 합의해 두는 것이 좋습니다.

- **[타입 선택]**
  - 절대 시점(로그, 이벤트 발생 시각 등): `TIMESTAMP` 또는 `DATETIME(UTC)`
  - 로컬 캘린더 시각(영업시간 등): `DATETIME`
- **[타임존 정책]**
  - 애플리케이션 내부 시간 기준 (UTC vs 특정 타임존)
  - MySQL 글로벌/세션 `time_zone` 설정 값
- **[경계/기간 정책]**
  - 기간 쿼리는 기본적으로 `[start, end)` 형태 사용
- **[생성/수정 시각 관리]**
  - DB가 `CURRENT_TIMESTAMP`로 관리할지, 애플리케이션이 모두 기록할지 결정

이 원칙들을 명확히 해두면, MySQL에서 날짜/시간 때문에 발생하는 대부분의 혼란과 버그를 초기에 상당 부분 줄일 수 있습니다.
