# Kubernetes

## 개요

쿠버네티스에 대해 학습합니다.

<br />

## 목차

<br />
<br />

## 1. 컨테이너

<br />

### (1) 컨테이너 인프라 환경

<br />

![image](https://github.com/pinomaker-hoo/TIL/assets/56928532/925c1c73-e32e-4f67-81d6-2b6881c0106c)

<br />

컨테이너 인프라 환경은 컨테이너를 중심으로 구성된 인프라 환경이다. 컨테이너는 하나의 운영 체제 커널에서 다른 프로세스에 영향 받지 않고 독립적으로 실행되는 프로세스 상태를 의미한다.

컨테이너는 가상화 상태에서 동작하는 프로세스보다 더 가볍고 빠르게 동작한다.

### (2) 모놀리식 아키텍쳐, 마이크로서비스 아키텍쳐

<br />

![image](https://github.com/pinomaker-hoo/TIL/assets/56928532/4cd2c597-b1ff-4e27-8859-92a4061bd057)

모놀리식 아키텍쳐는 하나의 큰 목적이 있는 서비스에 여려 기능이 통합 되어있는 구조를 의미한다.

모놀리식 아키텍쳐에서는 소프트웨어가 하나의 결합된 코드로 구성되기에 초기 단계에서 설계하기 용이하고 코드 관리가 편하지만 서비스를 운영하는 과정에서 수정이 많을 경우에는 타 기능에 영향이 미칠 수 있고 단순했던 서비스 간의 관계가 복잡해질 수도 있다.

<br />

![image](https://github.com/pinomaker-hoo/TIL/assets/56928532/53e9210f-ae54-43d2-921d-8844201eab98)

그림처럼 여러가지 서비스가 하나의 서비스 안에 포함되면, 보안이나 데이터 베이스 접속과 같은 설정을 공통으로 하기에 개발 속도는 빠르지만 서버 증설이라던가, 에러 조치에 대해서 어려움이 발생하여 마이크로서비스 아키텍쳐가 등장했다.

<br />

마이크로서비스 아키텍쳐는 시스템 전체가 하나의 목적을 바라보는 것은 같지만, 개별 기능을 하는 작은 서비스를 각각 개발하여 연결하는 점이 다르다.

보안, 인증등과 관련된 기능이 독립된 서비스를 구성하고 있으며, 다른 서비스들도 독립적으로 동작할 수 있는 완결된 구조다.

이런 구조는 개발된 서비스를 재사용하기 쉽고, 향후 서비스가 변경됐을 때 다른 서비스에 영향을 미칠 가능성이 줄고 사용량의 변화에 따라 특정 서비스만 확장할 수 있다.

<br />

![image](https://github.com/pinomaker-hoo/TIL/assets/56928532/79fb7394-14d4-46a3-8c37-2b4141f52290)

<br />

마이크로서비스 아키텍쳐는 API 게이트웨이와 REST API를 이용한 통신 방식으로 사용자(외부)의 요청을 전달한다. 또한 서비스의 개수가 고정이 아니기에 어떤 서비스가 등록되어있는 지 파악하기 위해 서비스 디스커버리를 사용하고, 수많은 서비스의 내부 통신을 이벤트로 일원화하고 이를 효과적으로 관리하기 위한 이벤트 버스를 서비스로 구성한다.

## 2. 쿠버네티스

(1) 컨테이너 인프라 환경

컨테이너 인프라 환경이란 리눅스 운영 체제의 커널 하나에서 여러 개의 컨테이너가 격리된 상태로 실행되는 인프라 환경을 의미한다.

개인 환경에서는 사용자가 다양한 응용 프로그램을 사용하기에 각각의 프로그램을 컨테이너로 구현할 필요가 없었으나, 기업 환경에서는 다수의 관리자가 수백 또는 수천 대의 서버를 함께 관리하기에 일관성을 유지하는 것이 매우 중요하다.

가상화 환경에서는 각각의 가상 머신이 모두 독립적인 운영 체제 커널을 가지고 있어야하기에 그만큼 자원을 더 소모해야하고 성능이 떨어지지만 컨테이너 인프라 환경은 운영 체제 커널 하나에 컨테이너 여러개가 격리된 형태로 실행되기 때문에 자원을 효울적으로 사용할 수 있고 속도도 빠르다.

![image](https://github.com/pinomaker-hoo/TIL/assets/56928532/55e86c25-bfa1-4723-a1a6-027431ab63f0)

(2) 쿠버네티스의 이해

쿠버네티스는 컨테이너 오케스트레이션을 위한 솔루션이다. 오케스트레이션이란 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록 서비스를 제공하는 것을 의미한다.
즉 다수의 컨테이너를 유기적으로 연결, 실행, 종료를 하고 상태를 추적하고 보존하는 등의 컨테이너를 안정적으로 사용할 수 있게 하는 것이다.

쿠버네티스에는 kubectl, kubelet, API 서버 등 다양한 요소가 있으며 이들의 유기적인 관계를 이미지로 표한한 것이 아래의 이미지다.

![image](https://github.com/pinomaker-hoo/TIL/assets/56928532/3c598ec1-f74e-4568-a227-739a3b7ea0fd)

0. Kubectl

   쿠버네티스 클러스터에 명령을 내리는 역할을 하며, 다른 구성 요소들과 다르게 바로 실행되는 명령 형태인 바이너리로 배포되기에 마스터 노드에 있을 필요는 없다.

1. API 서버

   쿠버네티스 클러스터의 중심 역할을 하는 통로로, 주로 상태 값을 저장하는 etcd와 통신하지만, 그 밖에 요소들도 API 서버를 중심에 두고 소통하게 된다.

2. etcd

   구성 요소들의 상태 값이 모두 저장되는 곳으로, etcd의 정보만 백업되어있다면 쿠버네티스 클러스트는 복구할 수 있으며, key-value 형태의 저장소이기에 분산 저장이 가능하다.

3. 컨트롤러 매니저

   컨트롤러 매니저는 쿠버네티스 클러스터의 오브젝트 상태를 관리한다. 워커 노드에서 통신이 되지 않으면 상태 체크와복구를 컴트롤러 매니저에 속한 노드 컨트롤러에서 진행하게 된다.

4. 스케줄러

   노드의 상태와 자원, 레이블, 요구 조건등을 고려하여 파드를 어떤 노드워커에 생성할 것인지 결정하고 할당한다.

5. kubelet

   파드의 구성 내용인 PodSpec를 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는 지 모니터링한다.

6. 컨테이너 런타임

   파드를 이루는 컨테이너의 실행을 담당하며, 다양한 종류의 컨테이너가 문제 없이 작동하게 만드는 표준 인터페이스다.

7. 파드

   한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위로 웹 서버 역할을 할 수도 있고 로그나 데이터를 분석할 수도 있다. 파드는 언제든 죽을 수 있는 리소스다.

8. 네트워크 플러그인

   쿠버네티스 클러스터의 통신을 위해 네트워크 플러그인을 선택하고 구성해야한다. 주로 CNI로 구성한다.

9. CoreDNS

   쿠버네티스 클러스터에서 도메인 이름을 이용하여 통신하는 데 사용한다.

<br />

위에서 나온 것 중에서 쿠버네티스에서는 오브젝트라는 것이 존재한다.

오브젝트란 스펙과 상태 등의 값을 가지고 있는 파드와 디플리먼트를 개별 속성을 포함해 부르는 단위를 오브젝트라고 한다. 기본 오브젝트에는 4가지 존재가 있다.

- 파드

  쿠버네티스에서 실행되는 최소 단위로 웹 서비스를 구동하는 데 필요한 최소 단위이기에, 독립적인 공간과 사용 가능한 IP를 가지고 있다. 1개의 파드는 1개 이상의 컨테이너를 가지고 있다.

- 네임스페이스

  쿠버네티스 클러스터에서 사용되는 리소스들을 구분해 관리하는 그룹이다.

- 볼륨

  파드가 생성될 때 파드에서 사용할 수 있는 디렉터리를 제공하는 데, 기본적으로 파드는 영속되는 개념이 아니기에 제공되는 디렉토리도 임시로 사용하지만, 파드가 사라지더라도 저장과 보존이 가능한 디렉터리를 볼륨 오브젝트를 통해 생성하고 사용할 수 있다.

- 서비스

  파드는 클러스터 내에서 유동적이기 때문에 접속 정보가 고정일 수가 없기에 파드 접속을 안정적으로 유지하도록 서비스를 통하여 내/외부로 연결된다. 서비스는 새로 파드가 생성될 때 부여되는 새로운 IP를 기존에 제공하던 기능과 연결해준다.
